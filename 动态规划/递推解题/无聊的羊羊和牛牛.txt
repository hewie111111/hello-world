
牛牛和羊羊非常无聊.他们有n + m个共同朋友,他们中有n个是无聊的,m个是不无聊的。每个小时牛牛和羊羊随机选择两个不同的朋友A和B.(如果存在多种可能的pair(A, B),任意一个被选到的概率相同。),然后牛牛会和朋友A进行交谈,羊羊会和朋友B进行交谈。在交谈之后,如果被选择的朋友之前不是无聊会变得无聊。现在你需要计算让所有朋友变得无聊所需要的时间的期望值。
输入描述:
输入包括两个整数n 和 m(1 ≤ n, m ≤ 50)
输出描述:
输出一个实数,表示需要时间的期望值,四舍五入保留一位小数。
示例1
输入
2 1
输出
1.5



//四舍五入保留K位小数
double roundk(double num, int k) {
    return round(num * pow(10, k)) / pow(10, k);
}
 
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    int s = n + m;
    double f0 = 0, f1 = s / 2.0;
    for(int k = 2; k <= m; k++) {
        double cur = s * (s - 1) / (1.0 * k * (2 * s - k - 1)) + 2 * (s - k) * 1.0 / (2 * s - k - 1) * f1 + (k - 1) * 1.0 / (2 * s - k - 1) * f0;
        f0 = f1;
        f1 = cur;
    }
    printf("%.1f\n", roundk(f1, 1));
    return 0;
}

即使以前抽过的人，还会被重新抽到，没有考虑的很细


这个题怎样才能想到递推？经过一次谈话的状态就能分析出用递归，肯定是n和n-1有了关系，才往递推靠拢的 